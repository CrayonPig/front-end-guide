# 常量和变量

## 常量

虽然在 `Node.js` 中可以使用`let`、`var`、`const`等关键词创建一个变量，程序运行也不会报错。但在当前主流代码规范中，仍然会要求我们对于常量使用`const`关键词声明，并且全部字母都使用大写，并使用下划线分隔单词。部分严格的代码规范会要求对数字字面量插入下划线以提高可读性。

```js
const MAX_LENGTH = 100_000;
```

很巧的是，在 `Rust` 中，对于常量的要求，也是一模一样的，并且更为严格一些

1. 常量使用`const`关键词声明
2. 命名中全部字母都使用大写并使用下划线分隔单词
3. 对数字字面量插入下划线
4. 值的类型必须标注
5. 常量自始至终不可变

上述常量声明对应是

```rs
const MAX_LENGTH: u32 = 100_000;
```

> u32是 `Rust` 中的代码标注，表示类型声明，类似于TypeScript的写法。此处表示无符号32位整数，只能存储32位的非负整数值。

## 变量

### 变量命名

`Rust` 中的变量命名跟 `Node.js` 没有区别，除了需要注意基本的规范外，还需要注意[关键字](https://kaisery.github.io/trpl-zh-cn/appendix-01-keywords.html)的规避。

### 变量绑定

在 `Node.js` 中，我们使用`var` 、 `let` 关键词对变量进行赋值，如

```js
var a = "Hello World";
let a = "Hello World";
```

而在 `Rust` 中，只允许使用 `let` 对变量进行赋值，如

```rs
let a = "Hello World";
```

上述示例可以发现，`Rust` 中变量的声明，跟`Node.js`中的`let`用法一样，那么这里为什么要说是变量绑定呢，这是因为 `Rust` 中有一个核心原则——**所有权**，在后续的章节我们详细说明。这里简单理解为，**在`Rust` 中，任何内存对象都有一个被称为所有者的变量，同时每个值也只有一个所有者**。类似于一个绑定关系，所以这里称之为变量绑定

### 变量可变性

在 `Node.js` 中，任何变量都是可变的，如

```js
let a = "Hello World";
a = "Hello JavaScript";
```

上述的操作在`Node.js`是被允许的。但在 `Rust` 中，变量在默认情况下是不可变的，一旦为变量绑定一个值，就不能再修改。比如上述代码转换为`Rust`后，

```rs
let a = "Hello World";
a = "Hello JavaScript";
```

编译后运行，会报错

```shell
error[E0384]: cannot assign twice to immutable variable `a`
 --> src/main.rs:3:3
  |
2 |   let a = "Hello World";
  |       -
  |       |
  |       first assignment to `a`
  |       help: consider making this binding mutable: `mut a`
3 |   a = "Hello JavaScript";
  |   ^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable
```

具体的错误原因是 `cannot assign twice to immutable variable a`（无法对不可变的变量进行重复赋值），因为我们想为默认不可变的 a 变量再次赋值。

那可能有些同学就比较迷茫，不能改变值的为啥要叫变量？

其实这是 `Rust` 团队设计的语言特性之一。在实际开发中，我们经常遇到一个变量在多处代码中被使用，在其中一部分代码中，该变量的值永远不会发生变化，而在另一部分代码中，该变量的值会被改变。在这种场景编写代码错误，在运行前很难被发现，无形中增大了我们的工作量。

`Rust`团队采用`变量默认不可变`的规则，让我们代码变得更加清晰，只有在你需要的变量发生变动时，才能改变，这样就不会造成心智上的负担，也给别人阅读代码带来便利。

在`Rust`中想让变量可变时，只需要在变量前增加一个关键字 `mut`，如

```rs
let a mut = "Hello World";
a = "Hello JavaScript";
```

这样的显示声明也会让别人阅读你的代码时，下意识的明白，这个变量在后续会发生变更。

### 变量遮蔽

`Node.js` 中有一个我们经常使用到，但可能忽略的特性，`变量遮蔽`，举个简单的例子

```js
let x = 10;

function example() {
  let x = 20; // 内部作用域中声明了一个名为 x 的变量，遮蔽了外部作用域的 x 变量
  console.log("Inner x:", x); // 输出内部作用域中的 x 变量，值为 20
}

example();
console.log("Outer x:", x); // 外部作用域中的 x 变量仍然可访问，值为 10
```

在这个例子中，函数 `example` 内部声明了一个名为 `x` 的变量，它遮蔽了外部作用域中的 `x` 变量。在函数内部，通过 `console.log` 输出的 `x` 是内部作用域中的变量，其值为 `20`。而在函数外部，外部作用域中的 `x` 仍然是可访问的，其值为 `10`。

在 `Rust` 中同样的允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如

```rs
fn main() {
    let x = 10;

    {
        let x = 20; // 内部作用域中重新声明了一个名为 x 的变量，遮蔽了外部作用域的 x 变量
        println!("Inner x: {}", x); // 输出内部作用域中的 x 变量，值为 20
    }

    println!("Outer x: {}", x); // 外部作用域中的 x 变量仍然可访问，值为 10
}
```

在这个例子中，内部作用域中的 `let x = 20;` 重新声明了一个名为 `x` 的变量，遮蔽了外部作用域中的 `x` 变量。在内部作用域中，通过 `println!` 输出的 `x` 是内部作用域中的变量，其值为 `20`。而在外部作用域中，外部作用域中的 `x` 仍然是可访问的，其值为 `10`。

细心的同学已经发现了，变量遮蔽和使用 `mut` 关键字不同，上述写法中 `let` 生成了一个新的变量，只是这个变量恰好跟之前的变量拥有同一个名字，涉及到内存对象的再分配。而 `mut` 关键字声明的变量，可以修改同一个内存地址上的值，并不会发生对象的再分配，性能要更好一些。

那既然 `mut` 关键字声明的方法性能会更好一些，为什么 `Rust` 要设计变量遮蔽的形式呢？

其实我们从之前的例子可以看出，变量遮蔽有助于避免命名冲突和意外的副作用，同时也提供了更灵活的命名空间。当然，过度使用变量遮蔽可能会导致代码可读性降低，因此应谨慎使用。

